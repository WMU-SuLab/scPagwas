}
run_FAMD_and_hclust=function(FAMD_final_input, metric, method){
#Perform FAMD or PCA or MCA
if( all(lapply(FAMD_final_input,class) %in% c("numeric","integer")) ){
# Quantitate factors only -> PCA
res.A=PCA(FAMD_final_input, graph=F, ncp=min(dim(FAMD_final_input))-1)
} else if ( all(!lapply(FAMD_final_input,class) %in% c("numeric","integer")) ){
# Qualitative factors only -> MCA
res.A=MCA(FAMD_final_input, graph=F, ncp=min(dim(FAMD_final_input))-1)
} else {
# Mixed data -> FAMD
res.A=FAMD(FAMD_final_input, graph=F, ncp=min(dim(FAMD_final_input))-1)
}
# Get coordinates, calculate distance and perform hierarchical clustering
# Took from the HCPC function of FactoMineR package
X = as.data.frame(res.A$ind$coord)
do <- dist(X, method = metric)^2
weight = rep(1, nrow(X))
eff <- outer(weight, weight, FUN = function(x, y, n) {
x * y/n/(x + y)
}, n = sum(weight))
dissi <- do * eff[lower.tri(eff)]
hc <- hclust(dissi, method = method, members = weight)
return(hc)
}
dist_method=match.arg(dist_method)
hclust_method=match.arg(hclust_method)
if(!is.null(dend_x_var)){
# x dendrogramm
# For the PCA/MCA/FAMD, we change the factor names in factor_1, factor2 ... to avoid syntax problem
if(class(save.data[,1])!="factor"){save.data[,1]=as.factor(save.data[,1])}
old_levels=levels(save.data[,1])
save.data[,1]=paste("factor", as.numeric(save.data[,1]), sep="_")
check_x=check_FAMD_var(dend_x_var, type="x",save.data=save.data)
if (check_x$success){
FAMD_x_input=format_FAMD_input(check_x$famd_input, type="x", save.data=save.data)
hc_x_result=run_FAMD_and_hclust(FAMD_x_input, metric=dist_method, method=hclust_method)
}else{
#check_x$success==FALSE
stop(check_x$message)
}
# Reorder x axis according to dendrogramms
data.to.plot[,1]<- factor(data.to.plot[,1],
levels = old_levels[as.numeric(gsub("factor_","",hc_x_result$labels[hc_x_result$order]))])
save.data[,1]=data.to.plot[,1]
}else{hc_x_result=NULL}
if(!is.null(dend_y_var)){
#y dendrogram
# For the PCA/MCA/FAMD, we change the factor names in factor_1, factor2 ... to avoid syntax problem
if(class(save.data[,2])!="factor"){save.data[,2]=as.factor(save.data[,2])}
old_levels=levels(save.data[,2])
save.data[,2]=paste("factor",as.numeric(save.data[,2]),sep="_")
check_y=check_FAMD_var(dend_y_var, type="y",save.data=save.data)
if (check_y$success){
FAMD_y_input=format_FAMD_input(check_y$famd_input, type="y", save.data=save.data)
hc_y_result=run_FAMD_and_hclust(FAMD_y_input, metric=dist_method, method=hclust_method)
}else{
#check_y$success==FALSE
stop(check_y$message)
}
# Reorder y axis according to dendrogramms
data.to.plot[,2]<- factor(data.to.plot[,2],
levels = old_levels[as.numeric(gsub("factor_","",hc_y_result$labels[hc_y_result$order]))])
save.data[,2]=data.to.plot[,2]
}else{hc_y_result=NULL}
### 3: GGPlot object ----
scale.func <- switch(EXPR = scale.by, size = scale_size,
radius = scale_radius, stop("'scale.by' must be either 'size' or 'radius'"))
# Set theme function. Common function between classical dotplot and pacman plot
# Transparent background, black border, no grid
set_background=function(p, xlims, ylims, vertical_coloring, horizontal_coloring){
p <- p + theme(
panel.background = element_rect(fill="transparent",linetype="solid", color="black"),
panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
legend.key = element_rect(colour = NA, fill = NA), axis.ticks = element_blank(),
plot.margin = unit(c(0,0,0,0), "points")
)
p <- p + coord_cartesian(xlim=xlims,ylim=ylims,expand=FALSE, default=T)
# Vertical coloring
if(any(!is.na(vertical_coloring))){
shading <- data.frame(min = c(0.5,seq(from = 1.5, to = max(as.numeric(as.factor(data.to.plot[,1]))), by = 1)),
max = c(seq(from = 1.5, to = max(as.numeric(as.factor(data.to.plot[,1]))) + 0.5, by = 1) ))
# shading$col = rep_len(x=c(NA,"gray80"),length.out=length(unique(data.to.plot[,1]))))
shading$col=rep(vertical_coloring, length.out=nrow(shading))
p <- p + annotate(geom = "rect", xmin = shading$min, xmax = shading$max,
ymin = 0.5, ymax = max(as.numeric(data.to.plot[,2]))+0.5, fill = shading$col, col="black")
# Adding black lines to delimitate shades
# We use another annotate to not display first and last line; otherwise add colour="black" in the previous annotate
p <- p + annotate(geom = "segment", x = c(shading$min[-1], shading$max[-length(shading$max)]),
xend = c(shading$min[-1], shading$max[-length(shading$max)]),
y = 0.5, yend = max(as.numeric(data.to.plot[,2]))+0.5,
colour = "black")
}
# Horizontal coloring
if(any(!is.na(horizontal_coloring))){
shading <- data.frame(min = seq(from = 0.5, to = max(as.numeric(as.factor(data.to.plot[,2]))), by = 1),
max = seq(from = 1.5, to = max(as.numeric(as.factor(data.to.plot[,2]))) + 0.5, by = 1))
# shading$col = rep_len(x=c(NA,"gray80"),length.out=length(unique(data.to.plot[,2])))
shading$col=rep(horizontal_coloring, length.out=nrow(shading))
p <- p + annotate(geom = "rect", xmin=0.5,xmax=max(as.numeric(data.to.plot[,1]))+0.5, ymin = shading$min, ymax = shading$max,
fill = shading$col, col="black")
# Adding black lines to delimitate shades
# We use another annotate to not display first and last line; otherwise add colour="black" in the previous annotate
p <- p + annotate(geom = "segment", x=0.5,xend=max(as.numeric(data.to.plot[,1]))+0.5, y = c(shading$min[-1], shading$max[-length(shading$max)]),
yend = c(shading$min[-1], shading$max[-length(shading$max)]),
colour = "black")
}
return(p)
}
get_shape_colors=function(data.to.plot, cols.use="default", color.breaks.values, color.breaks.number){
# Functions wich define a color of each data.to.plot row according to the 4th column
# Return a list containing :
#   $palette : used color palette
#   $colors : color of each row
#   $labels : labels for legend (continuous color only)
#   $breaks : legend breaks (continuous color only)
shape_colors_labels=list()
if (is.numeric(data.to.plot[,4])){
if (length(x = cols.use) == 1) {
shape_colors_labels$colors=rep(cols.use, nrow(data.to.plot)) # Monochrome
}
if (!(all(is.na(color.breaks.values)))){
if(all(is.numeric(color.breaks.values))){
cat("\n Putting color.breaks.values in color legend")
shape_colors_labels$breaks=color.breaks.values
}else{
cat("\n Non numeric value in color.breaks.values, considering color.breaks.number instead")
shape_colors_labels$breaks=(seq(min(na.omit(data.to.plot[,4])),max(na.omit(data.to.plot[,4])), length.out=color.breaks.number))
}
}else{
shape_colors_labels$breaks=(seq(min(na.omit(data.to.plot[,4])),max(na.omit(data.to.plot[,4])), length.out=color.breaks.number))
}
color_breaks=shape_colors_labels$breaks
shape_colors_labels$labels=ifelse((abs(color_breaks)<1e-2 | abs(color_breaks)>1e2) & color_breaks!=0,
format(color_breaks, scientific=TRUE, digits=3),
round(color_breaks,2)) # Values <1e-3 or >1e3 (excepted 0), are displayed with scientific notation
map2color<-function(x,pal,limits=NULL){
if(is.null(limits)) limits=range(x, na.rm = T)
pal[findInterval(x,seq(limits[1],limits[2],length.out=length(pal)+1), all.inside=TRUE)]
}
shape_colors_labels$colors=map2color(data.to.plot[,4], pal=colorRampPalette(cols.use)(100))
# if (length(x = cols.use) == 2){
#   p <- p + scale_fill_gradient(low = cols.use[1], high = cols.use[2],
#                                breaks=color_breaks, labels=color_labels) # Gradient from the first color to the second
# } else {
#   p <- p + scale_fill_gradientn(colours=cols.use, breaks=color_breaks, labels=color_labels)
# }
} else {
# discrete colors
if(all(cols.use !="default")){
if (length(cols.use)>length(unique(data.to.plot[,4]))){
cols.use=cols.use[1:length(unique(data.to.plot[,4]))]
cat(paste("\n To much colors are supplied. Only the first",length(unique(data.to.plot[,4])),"are used"))
} else if (length(cols.use)<length(unique(data.to.plot[,4]))){
cols.use=rep_len(cols.use, length.out = length(unique(data.to.plot[,4])))
cat(paste("\n The number of colors is lower than the modality number. Re-using colors"))
}
# p <- p + scale_fill_manual(values = cols.use)
}
else{
#reproducing ggplot2 default discrete palette
gg_color_hue <- function(n) {
hues = seq(15, 375, length = n + 1)
hcl(h = hues, l = 65, c = 100)[1:n]
}
cols.use=gg_color_hue(length(unique(data.to.plot[,4])))
}
shape_colors_labels$colors=cols.use[as.factor(data.to.plot[,4])]
shape_colors_labels$labels=levels(as.factor(data.to.plot[,4]))
}
shape_colors_labels$palette=cols.use
return(shape_colors_labels)
}
get_legend<-function(myggplot){
tmp <- ggplot_gtable(ggplot_build(myggplot))
leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
legend <- tmp$grobs[[leg]]
return(legend)
}
#Need to specify xlims and ylims of plot - this lets us calculate the normalised plot coordinates
xlims <- c(0.5,length(unique(data.to.plot[,1]))+0.5)
ylims <- c(0.5,length(unique(data.to.plot[,2]))+0.5)
### 3.1: PACMAN PLOT ----
### 3.2: DOT PLOT ----
# ggplot object initilization
p <- ggplot(mapping = aes(x = as.numeric(data.to.plot[,1]), y = as.numeric(data.to.plot[,2]), label=data.to.plot[,5]))
# theme function
p <- set_background(p, xlims, ylims, vertical_coloring, horizontal_coloring)
# Displaying shapes
# if(length(shape)==1){
p <- p + geom_point(mapping = aes(size = data.to.plot[,3], color = data.to.plot[,4]), shape=shape)
# Displaying maximal shapes area (only when shape %in% c(15,16,17,18))
if (all(shape %in% c(15,16,17,18)) & display_max_sizes){
background_shape=ifelse(shape %in% c(15,16,17),shape-15, shape-13)
p <- p + geom_point(mapping = aes(size = max(na.omit(data.to.plot[,3]))), colour="black",shape=background_shape)
}
# Changing shape size + shape size legend
if(!no_size_legend){
if (!(all(is.na(size.breaks.values)))){
if(all(is.numeric(size.breaks.values))){
cat("Putting size.breaks.values in size legend")
legend_breaks=size.breaks.values
}else{
cat("Non numeric value in size.breaks.values, considering size.breaks.number instead")
legend_breaks=(seq(min(na.omit(data.to.plot[,3])),max(na.omit(data.to.plot[,3])), length.out=size.breaks.number))
}
}else{
legend_breaks=(seq(min(na.omit(data.to.plot[,3])),max(na.omit(data.to.plot[,3])), length.out=size.breaks.number))
}
legend_labels=ifelse((abs(legend_breaks)<1e-2 | abs(legend_breaks)>1e2) & legend_breaks!=0,
format(legend_breaks, scientific=TRUE, digits=3),
round(legend_breaks,2)) # Values <1e-3 or >1e3 (excepted 0), are displayed with scientific notation
p <- p + scale.func(range = c(0.1, shape.scale),limits = c(scale.min, scale.max), breaks = legend_breaks, labels = legend_labels)
# /!\ It is important to no set the minimal range value to 0 (and >0.1) because its can induce shape size and position errors with specific shapes
}
# Coloring shapes
# Assign color to each point
plot_colors=get_shape_colors(data.to.plot, cols.use, color.breaks.values, color.breaks.number)
# Display colors
if (is.numeric(data.to.plot[,4])){
p <- p + scale_color_gradientn(colors=plot_colors$palette, breaks=plot_colors$breaks, labels=plot_colors$labels, na.value = "transparent")
}else{
p <- p + scale_color_manual(values = plot_colors$palette, na.value="transparent")
}
# Displaying text
p <- p + geom_text(aes(y = as.numeric(data.to.plot[,2]) + text.vjust), size=text.size)
### 3.3: Command lignes in common ----
# Legend titles
p$labels$size=size_legend
p$labels$colour=col_legend
p$labels$shape=shape_legend
# Deleting axis labels (printed in an other grob)
p <- p + scale_y_continuous(breaks = NULL,labels = NULL) + scale_x_continuous(breaks = NULL,labels = NULL)
# Deleting axis titles
p <- p + theme(axis.title.x = element_blank(), axis.title.y = element_blank())
# Remove panel border wich contain plot and legend
p <- p + theme(panel.background = element_rect(fill="transparent",linetype=0))
# Add panel border which contain plot only (legend outside) => /!\ It adds an additional margin in dotplot (not in pacman plot)
p <- p + geom_rect(aes(xmin=0.5,xmax=max(as.numeric(data.to.plot[,1]))+0.5,ymin=0.5,ymax=max(as.numeric(data.to.plot[,2]))+0.5), alpha=0, colour="black")
# Remove legend (printed in another grob)
dot_plot_legend=get_legend(p)
p <- p + theme(legend.position = "none")
### 4: Arrange plot with labels, dendrogramms and legends ----
final.plot.list=list()
# Plot number description :
# 1 : Horizontal dendrogram
# 2 : Top x labels
# 3 : Vertical dendrogram
# 4 : Left y labels
# 5 : Dotplot
# 6 : Right y labels
# 7 : Size legend
# 8 : Shape legend
# 9 : Color legend
# 10 : Bottom x labels
layout=rbind(c(NA,NA,1,NA,NA,NA,NA),
c(NA,NA,2,NA,NA,NA,NA),
c(3,4,5,6,7,8,9),
c(NA,NA,10,NA,NA,NA,NA))
widths=c(1,3,10,3,3,3,3)
x_lab_heights=3
heigths=c(1,x_lab_heights,10,x_lab_heights)
remove_geom <- function(ggplot2_object, geom_type) {
# Delete layers that match the requested type.
layers <- lapply(ggplot2_object$layers, function(x) {
if (class(x$geom)[1] %in% geom_type) {
NULL
} else {
x
}
})
# Delete the unwanted layers.
layers <- layers[!sapply(layers, is.null)]
ggplot2_object$layers <- layers
ggplot2_object
}
p_raw=remove_geom(p, c("GeomCustomAnn","GeomPoint","GeomRect","GeomText","GeomSegment"))
### 4.1 Axis Labels ----
# x_coords=rescale(x = 1:length(levels(data.to.plot[,1])), to = c(0,1), from=c(0.5,length(levels(data.to.plot[,1]))+0.5))
# final.plot.list[[2]]=dynTextGrob(levels(data.to.plot[,1]), x=x_coords, rot=ifelse(x.lab.rot, 90, 0),just="bottom", y=0.05, width=ifelse(x.lab.rot, 1, 1/length(levels(data.to.plot[,1]))* x.lab.size.factor))
# final.plot.list[[10]]=dynTextGrob(levels(data.to.plot[,1]), x=x_coords, rot=ifelse(x.lab.rot, 90, 0),just="top", y=0.95, width=ifelse(x.lab.rot, 1, 1/length(levels(data.to.plot[,1]))* x.lab.size.factor))
x_label_table=data.frame(xtext=levels(data.to.plot[,1]))
final.plot.list[[2]]= p_raw + geom_text(data = x_label_table, mapping = aes_(label=~xtext), y=0.05, x=1:length(levels(data.to.plot[,1])), hjust=0, vjust=0.5, angle=90, size=3.88*x.lab.size.factor)
final.plot.list[[2]]= final.plot.list[[2]]+
coord_cartesian(ylim = c(0,1),xlim=c(0.5,length(unique(data.to.plot[,1]))+0.5),expand=F, default = T) +
theme(plot.margin = unit(c(0,2,0,0), units = "points"), plot.background = element_rect(fill='transparent', color=NA))
final.plot.list[[10]]= p_raw + geom_text(data = x_label_table, mapping = aes_(label=~xtext), y=0.95, x=1:length(levels(data.to.plot[,1])), hjust=1, vjust=0.5, angle=90, size=3.88*x.lab.size.factor)
final.plot.list[[10]]= final.plot.list[[10]]+
coord_cartesian(ylim = c(0,1),xlim=c(0.5,length(unique(data.to.plot[,1]))+0.5),expand=F, default = T) +
theme(plot.margin = unit(c(2,0,0,0), units = "points"),plot.background = element_rect(fill='transparent', color=NA))
if(x.lab.pos == "top"){
heigths[4]=0
final.plot.list[[10]]=grob()
}else if (x.lab.pos=="bottom"){
heigths[2]=0
final.plot.list[[2]]=grob()
}else if (x.lab.pos == "none"){
heigths[c(2,4)]=0
final.plot.list[[2]]=grob()
final.plot.list[[10]]=grob()
}
# y_coords=rescale(x = seq(1, length(levels(data.to.plot[,2]))), to = c(0,1), from=c(0.5,length(levels(data.to.plot[,2]))+0.5))
# final.plot.list[[4]]=dynTextGrob(levels(data.to.plot[,2]), x=0.95, y=y_coords, width=0.95,just="right", adjustJust = F)
# final.plot.list[[4]]=textGrob(levels(data.to.plot[,2]),y=y_coords, x=0.95,gp = gpar(fontsize = 10), just="right")
# final.plot.list[[6]]=dynTextGrob(levels(data.to.plot[,2]), x=0.05, y=y_coords,  width=0.95,just="left")
y_label_table=data.frame(ytext=levels(data.to.plot[,2]))
final.plot.list[[4]]= p_raw + geom_text(data = y_label_table, mapping = aes_(label=~ytext), x=1, y=1:length(levels(data.to.plot[,2])), hjust=1, vjust=0.5, size=3.88*y.lab.size.factor)
final.plot.list[[4]]= final.plot.list[[4]]+coord_cartesian(xlim = c(0,1),ylim=c(0.5,length(unique(data.to.plot[,2]))+0.5),expand=F, default = T) +
theme(plot.margin = unit(c(0,2,2,0), units = "points"),plot.background = element_rect(fill='transparent', color=NA))
final.plot.list[[6]]= p_raw + geom_text(data = y_label_table, mapping = aes_(label=~ytext), x=0.05, y=1:length(levels(data.to.plot[,2])), hjust=0, vjust=0.5, size=3.88*y.lab.size.factor)
final.plot.list[[6]]= final.plot.list[[6]]+coord_cartesian(xlim = c(0,1),ylim=c(0.5,length(unique(data.to.plot[,2]))+0.5),expand=F, default = T) +
theme(plot.margin = unit(c(0,0,2,2), units = "points"), plot.background = element_rect(fill='transparent', color=NA))
if(y.lab.pos == "left"){
widths[4]=0
final.plot.list[[6]]=grob()
}else if (y.lab.pos=="right"){
widths[2]=0
final.plot.list[[4]]=grob()
}else if (y.lab.pos == "none"){
widths[c(2,4)]=0
final.plot.list[[4]]=grob()
final.plot.list[[6]]=grob()
}
### 4.2 Dendrogramms ----
# Arrange dotplot with dendrogramms
if(!is.null(hc_x_result)){
# Arrange x dendrogram
ddata_x <- segment(dendro_data(hc_x_result))
dendro_horizontal <- p_raw + geom_segment(data = ddata_x, mapping = aes_(x=~x,xend=~xend,
y=~y,yend=~yend, label=NULL))
dendro_horizontal <- dendro_horizontal+coord_cartesian(ylim = c(min(c(ddata_x$y,ddata_x$yend)),
max(c(ddata_x$y,ddata_x$yend))),
xlim=c(0.5,length(unique(data.to.plot[,1]))+0.5),
expand=F, default = T)+ theme(plot.margin = unit(c(2,0,2,0), units = "points"))
}
if(!is.null(hc_y_result)){
# Arrange y dendrogram
ddata_y <- segment(dendro_data(hc_y_result))
dendro_vertical <- p_raw + geom_segment(data = ddata_y, mapping = aes_(x=~length(unique(data.to.plot[,2]))+0.5-y,
xend=~length(unique(data.to.plot[,2]))+0.5-yend,
y=~x,yend=~xend, label=NULL))
dendro_vertical <- dendro_vertical+coord_cartesian(xlim = range(c(length(unique(data.to.plot[,2]))+0.5-ddata_y$y,length(unique(data.to.plot[,2]))+0.5-ddata_y$yend)),
ylim=c(0.5,length(unique(data.to.plot[,2]))+0.5),
expand=F, default = T) + theme(plot.margin = unit(c(0,0,0,2), units = "points"))
}
if(!is.null(hc_x_result) & !is.null(hc_y_result)){
final.plot.list[[1]]=dendro_horizontal
final.plot.list[[3]]=dendro_vertical
final.plot.list[[5]]=p
} else if (!is.null(hc_x_result)){
final.plot.list[[1]]=dendro_horizontal
final.plot.list[[3]]=grob()
final.plot.list[[5]]=p
widths[1]=0
} else if (!is.null(hc_y_result)){
final.plot.list[[1]]=grob()
final.plot.list[[3]]=dendro_vertical
final.plot.list[[5]]=p
heigths[1]=0
} else {
final.plot.list[[1]]=grob()
final.plot.list[[3]]=grob()
final.plot.list[[5]]=p
heigths[1]=0
widths[1]=0
}
### 4.3 Legends ----
# 7 : Size legend
# 8 : Shape legend
# 9 : Color legend
if (plot.legend){
if(is.numeric(shape) & length(shape)==nrow(data.to.plot) & plot.legend){
#pacman plot
# size legend
if(!no_size_legend){
final.plot.list[[7]]=size_leg
}else{
final.plot.list[[7]]=grob()
widths[5]=0
}
# shape legend
if(length(shape)==nrow(data.to.plot)){
final.plot.list[[8]]=shape_leg
}else{
final.plot.list[[8]]=grob()
widths[6]=0
}
# color legend
if(!no_color_legend){
final.plot.list[[9]]=col_leg
}else{
final.plot.list[[9]]=grob()
widths[7]=0
}
} else {
final.plot.list[[7]]=dot_plot_legend
final.plot.list[[8]]=grob()
final.plot.list[[9]]=grob()
widths[6:7]=0
}
}else{
final.plot.list[[7]]=grob()
final.plot.list[[8]]=grob()
final.plot.list[[9]]=grob()
widths[5:7]=0
}
### 4.4 Render plot ----
# return(final.plot.list) # for debug
final_plot=arrangeGrob(grobs = final.plot.list, layout_matrix = layout, widths = widths, heights = heigths)
if(do.plot){
grid.arrange(final_plot)
}
if (do.return) {
final_output=list()
final_output[["input_data"]]=save.data
final_output[["command"]]=sys.calls()[[1]]
final_output[["plot"]]=final_plot
if(!is.null(hc_y_result)){final_output[["dendrogram_y"]]=as.dendrogram(hc_y_result)}else{final_output[["dendrogram_y"]]=NULL}
if(!is.null(hc_x_result)){final_output[["dendrogram_x"]]=as.dendrogram(hc_x_result)}else{final_output[["dendrogram_x"]]=NULL}
if(!is.null(hc_y_result) | !is.null(hc_x_result)){final_output[["raw_dend_ggplot"]]=p_raw}
return(final_output)
}
### End function ----
}
load("E:/OneDrive/GWAS_Multiomics/ad_test/5.6test/Pagwas_GSE138852_Prune_adsubset_kegg.RData")
Pagwas[c("Pathway_ld_gwas_data","VariableFeatures","merge_scexpr",
"rawPathway_list",
"snp_gene_df")]<-NULL
names(Pagwas)
require("RColorBrewer")
require("Seurat")
require("SeuratObject")
require("ggsci")
library("RColorBrewer")
library("ggplot2")
library(scPagwas)
library(Seurat)
##导入开头处理的单细胞数据
Single_data =readRDS("E:/RPakage/scPagwas/inst/extdata/GSE138852_ad.rds")
scPagwas_p<-Pagwas$CellsrankPvalue$pValueHigh
names(scPagwas_p)<-rownames(Pagwas$CellsrankPvalue)
sum(scPagwas_p<0.05)
#pdf("E:/OneDrive/GWAS_Multiomics/ad_test/5.6test/ad_pruneGSE138852/tsne_test_ad.pdf")
DimPlot(Single_data,reduction="tsne",group.by = "oupSample.cellType",pt.size=0.8,
label = TRUE, repel=TRUE)+ labs(x="TSNE",y="")+
scale_color_d3() +
theme(aspect.ratio=1)
#dev.off()
fortify.Seurat <- function(x){
xy <- as.data.frame(Embeddings(x, reduction = "umap"))
colnames(xy) <- c("UMAP_1", "UMAP_2")
xy$UMAP_1 <- as.numeric(xy$UMAP_1)
xy$UMAP_2 <- as.numeric(xy$UMAP_2)
xy2 <- as.data.frame(Embeddings(x, reduction = "tsne"))
colnames(xy2) <- c("TSNE_1", "TSNE_2")
xy2$TSNE_1 <- as.numeric(xy2$TSNE_1)
xy2$TSNE_2 <- as.numeric(xy2$TSNE_2)
xy<-cbind(xy,xy2)
return(cbind(xy, as.data.frame(x@meta.data)))
}
all_fortify_can <- fortify.Seurat(Single_data)
Pagwas_fortify <- fortify.Seurat(Pagwas_seu)
rownames(Pagwas_fortify)<-colnames(Single_data)
#  pdf("E:/OneDrive/GWAS_Multiomics/ad_test/5.6test/ad_pruneGSE138852/Slingshot.plot.pdf")
DimPlot(Pagwas_seu,group.by = "annotation",label = F)+ #umap_theme()+ ggtitle("annotation")+
theme(aspect.ratio=1)
#  dev.off()
#Pagwas$Pathway_single_results
Pagwas$Celltype_anno$scPagwas_score<-Pagwas$scPagwas_score
Pagwas$Celltype_anno$pValueHigh <-Pagwas$CellsrankPvalue$pValueHigh
#Pagwas$Celltype_anno$slingPseudotime<- slingPseudotime[rownames(Pagwas$Celltype_anno)]
Pagwas_pca<-as.data.frame(t(data.matrix(Pagwas$Pathway_single_results)))
Pagwas_pca <- do.call(data.frame,                      # Replace Inf in data by NA
lapply(Pagwas_pca,
function(x) replace(x, is.infinite(x), NA)))
Pagwas_pca<- t(na.omit(t(Pagwas_pca)))
rownames(Pagwas_pca)<-colnames(Pagwas$Pathway_single_results)
Pagwas_seu<-CreateSeuratObject(
Pagwas_pca,
project = "CreateSeuratObject",
assay = "RNA",
names.field = 1,
names.delim = "_",
meta.data = Pagwas$Celltype_anno[colnames(Pagwas_pca),]
)
Idents(Pagwas_seu)<-Pagwas_seu$annotation
#ls_scCell_markerpa <- FindAllMarkers(object = ls_scCell)
#Pagwas_seu$slingPseudotime<-slingPseudotime[colnames(Pagwas_seu)]
Pagwas_seu<-ScaleData(Pagwas_seu)
Pagwas_seu <- FindVariableFeatures(object = Pagwas_seu,nfeatures = round(dim(Pagwas_seu)[1]*0.2))
Pagwas_seu <- RunPCA(object = Pagwas_seu, assay = "RNA", features = VariableFeatures(Pagwas_seu), npcs = 30)
Pagwas_seu <- RunTSNE(object = Pagwas_seu,assay = "RNA", reduction = "pca", dims = 1:30)
Pagwas_seu <- RunUMAP(object = Pagwas_seu, assay ="RNA", reduction = "pca", dims = 1:30)
Pagwas_fortify <- fortify.Seurat(Pagwas_seu)
rownames(Pagwas_fortify)<-colnames(Single_data)
#  pdf("E:/OneDrive/GWAS_Multiomics/ad_test/5.6test/ad_pruneGSE138852/Slingshot.plot.pdf")
DimPlot(Pagwas_seu,group.by = "annotation",label = F)+ #umap_theme()+ ggtitle("annotation")+
theme(aspect.ratio=1)
#  dev.off()
rownames(Pagwas_fortify)<-colnames(Single_data)
dim(Pagwas_fortify)
dim(Single_data)
colnames(Pagwas$data_mat)
rownames(Pagwas_fortify)<- colnames(Pagwas$data_mat)
dim(Pagwas$data_mat)
dim(Pagwas$Pathway_single_results)
rownames(Pagwas_pca)<-colnames(Pagwas$Pathway_single_results)
dim(Pagwas$Pathway_single_results)
dim(Pagwas_pca)
Pagwas_pca
names(Pagwas)
dim(Pagwas$pca_scCell_mat)
